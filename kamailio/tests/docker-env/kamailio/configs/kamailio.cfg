#!KAMAILIO
#!define FLT_ACC 1
#!define FLT_ACCMISSED 2
#!define FLT_ACCFAILED 3
#!define DBURL "sqlite:///etc/kamailio/kamailio.db"
#!subst "!INTERNAL_SUBNET!172.20.0.0/24!g"
#!subst "!CONTAINER_NAME!ddev-kamailio!g"

debug=1
log_stderror=yes
memdbg=5
memlog=5
log_prefix_mode=1
log_prefix="[$cfg(name):$cfg(line):$cfg(route)] [$ci:$rm:$rs] "
children=1
tcp_children=1
#sctp_children=1
auto_bind_ipv6=0
listen=udp:eth0:5060
listen=tcp:eth0:5060
listen=tls:eth0:5061
tcp_connection_lifetime=3605
tcp_max_connections=1024
tcp_accept_no_cl=yes
enable_tls=yes
enable_sctp=0
tls_max_connections=1024
mpath="/usr/lib/kamailio/modules/"

loadmodule "tls.so"
loadmodule "db_sqlite.so"
loadmodule "db_mysql.so"
loadmodule "kex.so"
loadmodule "corex.so"
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "usrloc.so"
loadmodule "registrar.so"
loadmodule "textops.so"
loadmodule "textopsx.so"
loadmodule "siputils.so"
loadmodule "dialog.so"
loadmodule "xlog.so"
loadmodule "sanity.so"
loadmodule "ctl.so"
loadmodule "cfg_rpc.so"
loadmodule "acc.so"
loadmodule "counters.so"
loadmodule "htable.so"
loadmodule "pike.so"
loadmodule "xhttp.so"
loadmodule "http_async_client.so"
loadmodule "jsonrpcs.so"
loadmodule "nathelper.so"
loadmodule "websocket.so"
loadmodule "ipops.so"
loadmodule "uac.so"
loadmodule "dispatcher.so"

modparam("ctl", "binrpc", "unix:/run/kamailio/kamailio_ctl")
modparam("ctl", "mode", 0600)
modparam("jsonrpcs", "pretty_format", 1)
modparam("jsonrpcs", "transport", 1)
modparam("sanity", "autodrop", 0)
modparam("tm", "failure_reply_mode", 3)
modparam("tm", "fr_timer", 30000)
modparam("tm", "fr_inv_timer", 120000)
modparam("rr", "enable_full_lr", 0)
modparam("rr", "append_fromtag", 0)
modparam("uac", "restore_mode", "none")
modparam("uac", "reg_db_url", DBURL)
modparam("uac", "reg_db_table", "uacreg")
modparam("uac", "reg_active", 1)
modparam("uac", "reg_contact_addr", "CONTAINER_NAME")
modparam("uac", "credential", "username:domain:password")
modparam("registrar", "method_filtering", 1)
modparam("registrar", "append_branches", 1)
modparam("registrar", "max_contacts", 1)
modparam("registrar", "max_expires", 3600)
modparam("registrar", "gruu_enabled", 0)
modparam("registrar", "use_path", 1)
modparam("registrar", "path_mode", 0)
modparam("acc", "early_media", 0)
modparam("acc", "report_ack", 0)
modparam("acc", "report_cancels", 0)
modparam("acc", "detect_direction", 0)
modparam("acc", "log_flag", FLT_ACC)
modparam("acc", "log_missed_flag", FLT_ACCMISSED)
modparam("acc", "log_extra", "src_user=$fU;src_domain=$fd;src_ip=$si;dst_ouser=$tU;dst_user=$rU;dst_domain=$rd")
modparam("acc", "failed_transaction_flag", FLT_ACCFAILED)
modparam("usrloc", "timer_interval", 60)
modparam("usrloc", "timer_procs", 1)
modparam("usrloc", "use_domain", 0)
modparam("tls", "config", "/etc/kamailio/tls.cfg")
modparam("pike", "sampling_time_unit", 2)
modparam("pike", "reqs_density_per_unit", 16)
modparam("pike", "remove_latency", 4)
modparam("htable", "htable", "ipban=>size=8;autoexpire=300;")
modparam("dispatcher", "db_url", DBURL)
modparam("dispatcher", "table_name", "dispatcher")
modparam("dispatcher", "ds_probing_mode", 1)
modparam("dispatcher", "ds_ping_latency_stats", 1)
modparam("dispatcher", "ds_ping_method", "OPTIONS")
modparam("dispatcher", "ds_ping_interval", 60)

request_route {
	route(REQINIT);

	if (is_method("CANCEL")) {
		if (t_check_trans()) {
			route(RELAY);
		}
		exit;
	}

	if (!is_method("ACK")) {
		if(t_precheck_trans()) {
			t_check_trans();
			exit;
		}
		t_check_trans();
	}

	route(WITHINDLG);
	route(AUTH);

	remove_hf("Route");
	if (is_method("INVITE|SUBSCRIBE")) {
		record_route();
	}

	if (is_method("INVITE")) {
		setflag(FLT_ACC); # do accounting
	}

	route(SIPOUT);
	route(PRESENCE);
	route(REGISTRAR);

	if ($rU==$null) {
		sl_send_reply("484","Address Incomplete");
		exit;
	}

	route(LOCATION);
	return;
}

route[RELAY] {
	if (is_method("INVITE|BYE|SUBSCRIBE|UPDATE")) {
		if(!t_is_set("branch_route")) t_on_branch("MANAGE_BRANCH");
	}
	if (is_method("INVITE|SUBSCRIBE|UPDATE")) {
		if(!t_is_set("onreply_route")) t_on_reply("MANAGE_REPLY");
	}
	if (is_method("INVITE")) {
		if(!t_is_set("failure_route")) t_on_failure("MANAGE_FAILURE");
	}

	if (!t_relay()) {
		sl_reply_error();
	}
	exit;
}

route[REQINIT] {
	set_reply_no_connect();
	force_rport();

	if(src_ip!=myself) {
		if($sht(ipban=>$si)!=$null) {
			xdbg("request from blocked IP - $rm from $fu (IP:$si:$sp)\n");
			exit;
		}
		if (!pike_check_req()) {
			xlog("L_ALERT","ALERT: pike blocking $rm from $fu (IP:$si:$sp)\n");
			$sht(ipban=>$si) = 1;
			exit;
		}
	}

	if($ua =~ "friendly|scanner|sipcli|sipvicious|VaxSIPUserAgent|pplsip") {
		sl_send_reply("200", "OK");
	}

	if (!mf_process_maxfwd_header("10")) {
		sl_send_reply("483","Too Many Hops");
		exit;
	}

	if(is_method("OPTIONS") && uri==myself && $rU==$null) {
		sl_send_reply("200","Keepalive");
		exit;
	}

	if(!sanity_check("17895", "7")) {
		xlog("Malformed SIP request from $si:$sp\n");
		exit;
	}
}

route[WITHINDLG] {
	if (!has_totag()) return;

	if (loose_route()) {
		if (is_method("BYE")) {
			setflag(FLT_ACC);
			setflag(FLT_ACCFAILED);
		}
        else if ( is_method("NOTIFY") ) {
			record_route();
		}
		route(RELAY);
		exit;
	}

	if (is_method("SUBSCRIBE") && uri == myself) {
		route(PRESENCE);
		exit;
	}
	if ( is_method("ACK") ) {
		if ( t_check_trans() ) {
			route(RELAY);
			exit;
		}
        else {
			exit;
		}
	}
	sl_send_reply("404","Not here");
	exit;
}

route[REGISTRAR] {
	if (!is_method("REGISTER")) return;

	if (!save("location")) {
		sl_reply_error();
	}
	exit;
}

route[LOCATION] {
	$avp(oexten) = $rU;
	if (!lookup("location")) {
		$var(rc) = $rc;
		t_newtran();
		switch ($var(rc)) {
			case -1:
			case -3:
				send_reply("404", "Not Found");
				exit;
			case -2:
				send_reply("405", "Method Not Allowed");
				exit;
		}
	}

	if (is_method("INVITE")) {
		setflag(FLT_ACCMISSED);
	}

	route(RELAY);
	exit;
}

route[PRESENCE] {
	if(!is_method("PUBLISH|SUBSCRIBE")) return;

	if(is_method("SUBSCRIBE") && $hdr(Event)=="message-summary") {
		sl_send_reply("404", "No voicemail service");
		exit;
	}

	if (is_method("PUBLISH") || $rU==$null) {
		sl_send_reply("404", "Not here");
		exit;
	}
	return;
}

route[AUTH] {
	if(uri!=myself) {
		sl_send_reply("403","Not relaying");
		exit;
	}
}

route[SIPOUT] {
	if (uri==myself) return;

	append_hf("P-Hint: outbound\r\n");
	route(RELAY);
	exit;
}

event_route[xhttp:request] {
	set_reply_close();
	set_reply_no_connect();

	if ($hu =~ "^/rpc") {
		if (!is_myself("$si") && !is_in_subnet($si, "INTERNAL_SUBNET")) {
			xlog("L_INFO", "$si denied access to rpc api (request from outside subnet)\n");
			xhttp_reply("403", "Forbidden", "", "");
			exit;
		}
		if ($hu =~ "^/rpc/auth") {
			if (!is_present_hf("Authorization")) {
				xlog("L_INFO", "$si denied access to rpc api (missing auth header)\n");
				xhttp_reply("401", "Unauthorized", "", "");
				exit;
			}
			if ($(hdr(Authorization){s.substr,0,7}) != "Bearer ") {
				xlog("L_INFO", "$si denied access to rpc api (unsupported auth method)\n");
				xhttp_reply("400", "Unsupported Authentication Method", "", "");
				exit;
			}

			$var(token) = $(hdr(Authorization){s.select,1, });
			if ($var(token) != "ANerqjNJ6cwCibGQDxtCfGlgHM2qfzzj") {
				xlog("L_INFO", "$si denied access to rpc api (bearer auth failed)\n");
				xhttp_reply("403", "Forbidden", "", "");
				exit;
			}
		}

		jsonrpc_dispatch();
		exit;
	}
	else if ($hdr(Upgrade) =~ "websocket" && $hdr(Connection) =~ "Upgrade" && $rm =~ "GET") {
		if (ws_handle_handshake()) {
			exit;
		}
	}

	xhttp_reply("404", "Not found", "", "");
	exit;
}

# Manage outgoing branches
branch_route[MANAGE_BRANCH] {
	xdbg("new branch [$T_branch_idx] to $ru\n");
	return;
}

# Manage incoming replies
reply_route {
	if(!sanity_check("17604", "6")) {
		xlog("Malformed SIP response from $si:$sp\n");
		drop;
	}
	return;
}

# Manage incoming replies in transaction context
onreply_route[MANAGE_REPLY] {
	xdbg("incoming reply\n");
	return;
}

# Manage failure routing cases
failure_route[MANAGE_FAILURE] {
	if (t_is_canceled()) exit;

#!ifdef WITH_BLOCK3XX
	# block call redirect based on 3xx replies.
	if (t_check_status("3[0-9][0-9]")) {
		t_reply("404","Not found");
		exit;
	}
#!endif

#!ifdef WITH_BLOCK401407
	# block call redirect based on 401, 407 replies.
	if (t_check_status("401|407")) {
		t_reply("404","Not found");
		exit;
	}
#!endif


	return;
}
